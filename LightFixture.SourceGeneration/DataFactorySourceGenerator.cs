using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using LightFixture.SourceGeneration.Constants;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace LightFixture.SourceGeneration;

[Generator]
public sealed class DataFactorySourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var targetSymbols = context.SyntaxProvider.ForAttributeWithMetadataName(
            WellKnownTypes.DataFactoryAttribute,
            (node, _) => node is ClassDeclarationSyntax,
            (ctx, _) => ctx.TargetSymbol);

        context.RegisterSourceOutput(targetSymbols, HandleSymbol);
    }

    private static void HandleSymbol(SourceProductionContext context, ISymbol symbol)
    {
        if (symbol is not INamedTypeSymbol namedType)
        {
            return;
        }

        var factoryDefinition = GetFactoryDefinition(namedType, context.CancellationToken);
        var typesToGenerate = WalkTypes(factoryDefinition);
        var factoryLookup = new Dictionary<ITypeSymbol, int>(SymbolEqualityComparer.Default);

        var code = new CodeBuilder();

        code
            .AppendLine("// <auto-generated />")
            .AppendLine()
            .AppendLine("using LightFixture;")
            .AppendLine()
            .AppendLine($"namespace {namedType.ContainingNamespace.ToDisplayString()};")
            .AppendLine()
            .AppendLine($"partial class {namedType.Name} : global::{WellKnownTypes.DataProviderCustomization}")
            .OpenBlock();

        var factoryNumber = 0;
        foreach (var type in typesToGenerate)
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            WriteAnonymousFactory(type);
            factoryNumber++;
        }

        code.AppendLine(CommonSyntax.GeneratedCodeAttribute)
            .AppendLine($"void global::{WellKnownTypes.DataProviderCustomization}.Apply(global::LightFixture.DataProviderBuilder builder)")
            .OpenBlock();
        foreach (var kvp in factoryLookup)
        {
            code.AppendLine($"builder.Register<{GetFullTypeName(kvp.Key)}>((p, _) => _Factory{kvp.Value}(p));");
        }

        code.CloseBlock();
        code.CloseBlock();

        context.AddSource(namedType.Name + ".g.cs", code.ToString());

        return;
        
        void WriteAnonymousFactory(ITypeSymbol type)
        {
            factoryDefinition.IgnoredProperties.TryGetValue(type, out var ignoredProperties);
            factoryLookup[type] = factoryNumber;

            var constructor = type is INamedTypeSymbol nt
                ? nt.Constructors
                    .Where(c => c is { IsStatic: false, DeclaredAccessibility: Accessibility.Public })
                    .OrderBy(x => x.Parameters.Length)
                    .FirstOrDefault()
                : null;
            var constructorParameters = constructor?.Parameters ?? ImmutableArray<IParameterSymbol>.Empty;
            var constructorParameterNames = new HashSet<string>(
                constructorParameters.Select(x => x.Name),
                StringComparer.InvariantCultureIgnoreCase);

            code.AppendLine(CommonSyntax.GeneratedCodeAttribute)
                .AppendLine($"private {GetFullTypeName(type)} _Factory{factoryNumber}(global::LightFixture.DataProvider provider)")
                .OpenBlock()
                .Append($"var o = new {GetFullTypeName(type)}(");

            for (var i = 0; i < constructorParameters.Length; i++)
            {
                var parameter = constructorParameters[i];
                code.Append($"provider.Resolve<{GetFullTypeName(parameter.Type)}>(")
                    .Append("new global::LightFixture.CreationRequest(")
                    .Append($"typeof({GetFullTypeName(parameter.Type)}),")
                    .Append($"\"{parameter.Name}\")).Value");

                if (i < constructorParameters.Length - 1)
                {
                    code.Append(", ");
                }
            }

            code.AppendLine(");");

            var count = 0;
            foreach (var member in type.GetMembers())
            {
                if (member is not IPropertySymbol { GetMethod: not null, SetMethod: not null } property
                    || constructorParameterNames.Contains(property.Name)
                    || ignoredProperties?.Contains(property.Name) is true)
                {
                    continue;
                }

                code.AppendLine($"var o{count} = provider.Resolve<{GetFullTypeName(property.Type)}>(")
                    .Indent()
                    .AppendLine("new global::LightFixture.CreationRequest(")
                    .Indent()
                    .AppendLine($"typeof({GetFullTypeName(property.Type)}),")
                    .AppendLine($"\"{property.Name}\"));")
                    .Outdent()
                    .Outdent()
                    .AppendLine($"if(o{count}.IsResolved)")
                    .OpenBlock()
                    .AppendLine($"o.{property.Name} = o{count}.Value;")
                    .CloseBlock();
                
                count++;
            }

            code.AppendLine("return o;")
                .CloseBlock()
                .AppendLine();
        }
    }

    private static string GetFullTypeName(ITypeSymbol type) => type switch
    {
        INamedTypeSymbol { IsGenericType: true, Name: "Nullable" } nullable => GetFullTypeName(
            nullable.TypeArguments[0]),
        { SpecialType: SpecialType.None, IsReferenceType: true, NullableAnnotation: NullableAnnotation.Annotated }
            => $"global::{type.ToDisplayString()}".Replace("?", string.Empty),
        { SpecialType: SpecialType.None } => $"global::{type.ToDisplayString()}",
        { SpecialType: SpecialType.System_String } => "string",
        _ => type.ToDisplayString(),
    };

    private static DataFactoryDefinition GetFactoryDefinition(INamedTypeSymbol symbol, CancellationToken token)
    {
        var definition = new DataFactoryDefinition();
        foreach (var attribute in symbol.GetAttributes())
        {
            token.ThrowIfCancellationRequested();
            switch (attribute.AttributeClass?.ToDisplayString())
            {
                case WellKnownTypes.DataFactoryAttribute:
                    HandleDataFactoryAttribute(definition, attribute);
                    break;
                case WellKnownTypes.DataFactoryIgnorePropertyAttribute:
                    HandleIgnorePropertyAttribute(definition, attribute);
                    break;
            }
        }

        return definition;

        static void HandleDataFactoryAttribute(DataFactoryDefinition definition, AttributeData data)
        {
            if (data.ConstructorArguments.Length is 1
                && data.ConstructorArguments[0].Value is ITypeSymbol type)
            {
                definition.RootTypes.Add(type);
            }
        }

        static void HandleIgnorePropertyAttribute(DataFactoryDefinition definition, AttributeData data)
        {
            if (data.ConstructorArguments.Length is 2
                && data.ConstructorArguments[0].Value is ITypeSymbol type
                && data.ConstructorArguments[1].Value is string property)
            {
                if (!definition.IgnoredProperties.TryGetValue(type, out var ignored))
                {
                    ignored = new();
                    definition.IgnoredProperties[type] = ignored;
                }
                ignored.Add(property);
            }
        }
    }

    private static IEnumerable<ITypeSymbol> WalkTypes(DataFactoryDefinition definition)
    {
        var explored = new HashSet<ITypeSymbol>(SymbolEqualityComparer.Default);
        var queue = new Queue<ITypeSymbol>(definition.RootTypes);

        while (queue.Count > 0)
        {
            var type = queue.Dequeue();
            yield return type;
            foreach (var member in type.GetMembers())
            {
                if (member is not IPropertySymbol { GetMethod: not null, SetMethod: not null } property
                    || IsIgnored(type, property.Name))
                {
                    continue;
                }

                if (!IsNativeType(property.Type) && explored.Add(property.Type))
                {
                    queue.Enqueue(property.Type);
                }
            }
        }
        
        yield break;

        bool IsIgnored(ITypeSymbol containingType, string propertyName)
        {
            return definition.IgnoredProperties.TryGetValue(containingType, out var ignored)
                && ignored.Contains(propertyName);
        }
    }

    private static bool IsNativeType(ITypeSymbol type)
    {
        if (type is INamedTypeSymbol { IsGenericType: true, Name: "Nullable" } nullable)
        {
            type = nullable.TypeArguments[0];
        }

        if (type.SpecialType is not SpecialType.None)
        {
            return true;
        }

        if (type.TypeKind is TypeKind.Enum)
        {
            return true;
        }

        if (type.ContainingNamespace.ToDisplayString() is "System.Collections.Generic")
        {
            return true;
        }

        return false;
    }

    private sealed class DataFactoryDefinition
    {
        public HashSet<ITypeSymbol> RootTypes { get; } = new(SymbolEqualityComparer.Default);

        public Dictionary<ITypeSymbol, HashSet<string>> IgnoredProperties { get; } = new(SymbolEqualityComparer.Default);
    }
}