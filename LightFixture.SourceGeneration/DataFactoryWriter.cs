using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using LightFixture.SourceGeneration.Constants;
using Microsoft.CodeAnalysis;

namespace LightFixture.SourceGeneration;

internal sealed class DataFactoryWriter
{
    public string WriteFactory(
        DataFactoryDefinition factoryDefinition,
        CancellationToken cancellationToken)
    {
        var typesToGenerate = factoryDefinition.WalkTypes();
        var factoryLookup = new Dictionary<ITypeSymbol, string>(SymbolEqualityComparer.Default);

        var code = new CodeBuilder();

        code
            .AppendLine("// <auto-generated />")
            .AppendLine("#nullable enable")
            .AppendLine()
            .AppendLine("using LightFixture;")
            .AppendLine()
            .AppendLine($"namespace {factoryDefinition.FactoryType.ContainingNamespace.ToDisplayString()};")
            .AppendLine()
            .AppendLine(
                $"partial class {factoryDefinition.FactoryType.Name} : global::{WellKnownTypes.DataProviderCustomization}")
            .OpenBlock();

        var factoryNumber = 0;
        foreach (var type in typesToGenerate)
        {
            cancellationToken.ThrowIfCancellationRequested();
            WriteAnonymousFactory(type);
            factoryNumber++;
        }

        code.AppendLine(CommonSyntax.GeneratedCodeAttribute)
            .AppendLine(
                $"void global::{WellKnownTypes.DataProviderCustomization}.Apply(global::LightFixture.DataProviderBuilder builder)")
            .OpenBlock();
        foreach (var kvp in factoryLookup)
        {
            code.AppendLine($"builder.Register<{GetFullTypeName(kvp.Key)}>((p, _) => {kvp.Value}(p));");
        }

        code.CloseBlock();
        code.CloseBlock();


        return code.ToString();

        void WriteAnonymousFactory(ITypeSymbol type)
        {
            factoryDefinition.IgnoredProperties.TryGetValue(type, out var ignoredProperties);
            var factoryMethodName = $"_Factory{factoryNumber}_{type.Name}";
            factoryLookup[type] = factoryMethodName;

            var constructor = type is INamedTypeSymbol nt
                ? nt.Constructors
                    .Where(c => c is { IsStatic: false, DeclaredAccessibility: Accessibility.Public })
                    .OrderBy(x => x.Parameters.Length)
                    .FirstOrDefault()
                : null;
            var constructorParameters = constructor?.Parameters ?? ImmutableArray<IParameterSymbol>.Empty;
            var constructorParameterNames = new HashSet<string>(
                constructorParameters.Select(x => x.Name),
                StringComparer.InvariantCultureIgnoreCase);

            var createdTypeName = GetFullTypeName(type);
            code.AppendLine(CommonSyntax.GeneratedCodeAttribute)
                .AppendLine(
                    $"private {createdTypeName} {factoryMethodName}(global::LightFixture.DataProvider provider)")
                .OpenBlock()
                .Append($"var o = new {createdTypeName}(");

            for (var i = 0; i < constructorParameters.Length; i++)
            {
                var parameter = constructorParameters[i];
                var parameterTypeName = GetFullTypeName(parameter.Type);
                code.Append($"provider.Resolve<{parameterTypeName}>(")
                    .Append("new global::LightFixture.CreationRequest(")
                    .Append($"typeof({parameterTypeName}),")
                    .Append($"\"{parameter.Name}\")).Value");

                if (i < constructorParameters.Length - 1)
                {
                    code.Append(", ");
                }
            }

            code.AppendLine(");");

            var count = 0;
            var propertiesToSet = GetPropertiesToSet(
                factoryDefinition,
                constructorParameterNames,
                type);

            foreach (var property in propertiesToSet)
            {
                code.Append($"var o{count} = provider.Resolve<{GetFullTypeName(property.Type)}>(")
                    .AppendLine($"new (typeof({GetFullTypeName(property.Type)}),\"{property.Name}\"));")
                    .AppendLine($"if(o{count}.IsResolved)")
                    .OpenBlock()
                    .AppendLine($"o.{property.Name} = o{count}.Value;")
                    .CloseBlock();

                count++;
            }

            code.AppendLine("return o;")
                .CloseBlock()
                .AppendLine();
        }
    }

    private static IEnumerable<IPropertySymbol> GetPropertiesToSet(
        DataFactoryDefinition definition,
        HashSet<string> constructorParameterNames,
        ITypeSymbol type)
    {
        var currentType = type;
        // Track already used members to handle hiding.
        var alreadyUsedMembers = new HashSet<string>();
        while (currentType is not null)
        {
            definition.IgnoredProperties.TryGetValue(currentType, out var ignoredProperties);
            alreadyUsedMembers.UnionWith(ignoredProperties ?? []);
            foreach (var member in currentType.GetMembers())
            {
                if (member is not IPropertySymbol { GetMethod: not null, SetMethod: not null } property
                    || constructorParameterNames.Contains(property.Name)
                    || !alreadyUsedMembers.Add(property.Name))
                {
                    continue;
                }

                yield return property;
            }

            currentType = currentType.BaseType;
        }
    }

    private static string GetFullTypeName(ITypeSymbol type) => type switch
    {
        INamedTypeSymbol { IsGenericType: true, Name: "Nullable" } nullable
            => GetFullTypeName(nullable.TypeArguments[0]),
        IArrayTypeSymbol { ElementType: var elementType } => $"{GetFullTypeName(elementType)}[]",
        { SpecialType: SpecialType.None, IsReferenceType: true, NullableAnnotation: NullableAnnotation.Annotated }
            => $"global::{type.ToDisplayString()}".Replace("?", string.Empty),
        { SpecialType: SpecialType.None } => $"global::{type.ToDisplayString()}",
        { SpecialType: SpecialType.System_String } => "string",
        _ => type.ToDisplayString(),
    };
}